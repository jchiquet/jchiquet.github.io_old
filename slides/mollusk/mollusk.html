<!DOCTYPE html>
<html>
  <head>
    <title>PLNmodels: a case study</title>
    <meta charset="utf-8">
    <meta name="author" content="PLN team" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/jquery/jquery.min.js"></script>
    <link href="libs/datatables-css/datatables-crosstalk.css" rel="stylesheet" />
    <script src="libs/datatables-binding/datatables.js"></script>
    <link href="libs/dt-core/css/jquery.dataTables.min.css" rel="stylesheet" />
    <link href="libs/dt-core/css/jquery.dataTables.extra.css" rel="stylesheet" />
    <script src="libs/dt-core/js/jquery.dataTables.min.js"></script>
    <link href="libs/crosstalk/css/crosstalk.css" rel="stylesheet" />
    <script src="libs/crosstalk/js/crosstalk.min.js"></script>
    <link rel="stylesheet" href="pln.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# PLNmodels: a case study
## The mollusk data set
### PLN team
### 2019/01 (last update: 2019-02-01)

---




class: inverse, center, middle

# Getting Started

---
# Requirements

## Package PLNmodels and dependencies

For this tutorial, you may preferably install the last release of **PLNmodels** from GitHub &lt;sup&gt;1&lt;/sup&gt;:


```r
devtools::install_github("jchiquet/PLNmodels@v7.0.1")
```

More details are available at https://jchiquet.github.io/PLNmodels/ about 

- installing the required dependencies 
    - a system version of `nlopt`, 
    - `CRAN` and `Bioconductor` R packages
- OS specificities (Windows binaries)

## Rstudio IDE

You are recommended to use the [RStudio IDE](https://www.rstudio.com/products/rstudio/) and `R 3.5.2`.

- Create a new `R` Markdown document from the menu `File -&gt; New File -&gt; R Markdown`

- Click the `Knit` button to compile it or (best) use  Ctrl/⌘ + ⇧ + K

---

# First steps

## Loading the package

Check that the installation process succeeded


```r
library(PLNmodels)
packageVersion("PLNmodels")
```

```
## [1] '0.7.0.1'
```

## Finding help and documentation

The [PLNmodels website](https://jchiquet.github.io/PLNmodels/) contains

- the standard package documentation 
- a set of comprehensive vignettes for the top-level functions

all formatted with [**pkgdown**](https://pkgdown.r-lib.org)


And do not forget `?`/`??` in the `R` console.

---

# Some additional useful packages

The tools provided by the two following libraries will be useful during our analyses.


```r
library(tidyverse) # data manipulation
```

```
## ── Attaching packages ──────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ──
```

```
## ✔ ggplot2 3.1.0     ✔ purrr   0.3.0
## ✔ tibble  2.0.1     ✔ dplyr   0.7.8
## ✔ tidyr   0.8.2     ✔ stringr 1.3.1
## ✔ readr   1.3.1     ✔ forcats 0.3.0
```

```
## ── Conflicts ─────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
```

```r
library(corrplot)  # plot of covariance/correlation matrices
```

```
## corrplot 0.84 loaded
```

---

class: inverse, center, middle

# The Mollusk data set &lt;br/&gt; insights and data preparation

---

# Data overview

The `mollusk` variable is loaded by the function `data()`. 

```r
data(mollusk)
```

It consists in a list of two data frames, typical from ecological data sets

- The `abundance` table contains the counts of 32 species in 163 samples; 
- The `covariate` table contains information about 4  environmental variables.


```r
str(mollusk, max.level = 1)
```

```
## List of 2
##  $ Abundance:'data.frame':	163 obs. of  32 variables:
##  $ Covariate:'data.frame':	163 obs. of  4 variables:
```

Have a look at the help page with `?mollusk` to get additional details.

### Reference

.small[Richardot-Coulet, M., Chessel D. and Bournaud M. (1986) Typological value of the benthos of old beds of a large river. Methodological approach. Archiv fùr Hydrobiologie, 107, 363–383.]

---

# Abundance table (I)


```r
mollusk$Abundance %&gt;% 
  dplyr::select(1:10) %&gt;% 
  head() %&gt;% DT::datatable(fillContainer = FALSE)
```

<div id="htmlwidget-f89cfdd82be5fbb3fed4" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-f89cfdd82be5fbb3fed4">{"x":{"filter":"none","fillContainer":false,"data":[["1","2","3","4","5","6"],[2,2,1,13,19,54],[0,0,0,0,0,0],[2,0,0,0,4,3],[0,0,0,0,0,0],[0,2,1,0,0,1],[0,0,0,0,0,0],[0,0,0,0,0,0],[22,93,39,1,2,2],[0,0,0,0,0,0],[0,0,0,0,0,0]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Bit<\/th>\n      <th>Vap<\/th>\n      <th>Vac<\/th>\n      <th>Gac<\/th>\n      <th>Raa<\/th>\n      <th>Rap<\/th>\n      <th>Lit<\/th>\n      <th>Pha<\/th>\n      <th>Phf<\/th>\n      <th>Plc<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6,7,8,9,10]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>

---

# Abundance table (II)


```r
t(log(1 + mollusk$Abundance)) %&gt;% 
  corrplot::corrplot(
    is.corr = FALSE,
    addgrid.col = NA, 
    tl.cex = .5, 
    cl.pos = "n"
  )
```

![](mollusk_files/figure-html/glance Abundances-1.png)&lt;!-- --&gt;

---

# Covariates

The three first covariates are categorical. The fourth one is numerical.

- `site`: sampling site
- `season`: winter, spring, summer, autumn
- `method`: sampling - wood or string
- `duration`: time of exposure (in week)


```r
summary(mollusk$Covariate)
```

```
##         site       season      method      duration    
##  Negria1  :24   automn:41   string:82   Min.   :3.000  
##  Negria2  :24   spring:44   wood  :81   1st Qu.:3.000  
##  Pecheurs1:24   summer:44               Median :6.000  
##  Pecheurs2:24   winter:34               Mean   :6.129  
##  GGravier3:22                           3rd Qu.:9.000  
##  GGravier1:21                           Max.   :9.000  
##  (Other)  :24
```

---

# Data preparation

In **PLNmodels**, data are handled into a single data frame that put together
1. the counts,
1. the potential covariates,
1. the offset that may be used in the models.

--

.important[_Important!_]

1. All the species found in the counts table will be used in the model,
2. The formula mechanism of `R` allows you to choose specific covariates or offsets.

--

The helping function `prepare_data` allows you to avoid taking care of cumbersome data manipulation &lt;sup&gt;1&lt;/sup&gt;.


```r
prepare_data(
  counts     = , # your count table
  covariates = , # your covariates
  offset     = , # the method to compute offset
)
```

.footnote[
[1] variants of `prepare_data` exist for [`biom`](http://biom-format.org/) file and objects build using the [`phyloseq`](https://joey711.github.io/phyloseq/) BioConductor package.
]
---

# Preparing the mollusk data set 

We choose here to consider the total sum of counts to build our vector of offsets


```r
mollusc &lt;- prepare_data(
    counts = mollusk$Abundance,
    covariates = mollusk$Covariate, 
*   offset = "TSS"  # look at other possible choices
  )
```

--

The structure of the final object is a data frame&lt;sup&gt;1&lt;/sup&gt;, but with some columns filled with matrices:


```r
str(mollusc, max.level = 1)
```

```
## 'data.frame':	159 obs. of  6 variables:
##  $ Abundance: int [1:159, 1:32] 2 2 1 13 19 54 32 6 24 15 ...
##   ..- attr(*, "dimnames")=List of 2
##  $ site     : Factor w/ 8 levels "GGravier1","GGravier2",..: 5 5 5 5 5 5 5 5 5 5 ...
##  $ season   : Factor w/ 4 levels "automn","spring",..: 4 4 4 2 2 2 3 3 3 1 ...
##  $ method   : Factor w/ 2 levels "string","wood": 2 2 2 2 2 2 2 2 2 2 ...
##  $ duration : num  3 6 9 3 6 9 3 6 9 3 ...
##  $ Offset   : num  83 203 93 18 41 96 174 22 104 88 ...
```

.footnote[
[1] Note that `mollusc` has 3 fewer samples than `mollusk`, as `prepare_data` automatically removed empty samples.
]

---

class: inverse, center, middle

# Multivariate Poisson Lognormal models with PLN

---

# The Poisson Lognormal model (PLN)

The PLN model is a multivariate generalized linear model, where 

- the counts `\(\mathbf{Y}_i\)` are the response variables
- the main effect is due to a linear combination of the covariates `\(\mathbf{x}_i\)`
- a vector&lt;sup&gt;1&lt;/sup&gt; of offsets `\(\mathbf{o}_i\)` can be specified for each sample.

$$
\mathbf{Y}_i | \mathbf{Z}_i \sim \mathcal{P}\left(\exp\{\mathbf{Z}_i\}\right), \qquad \mathbf{Z}_i \sim \mathcal{N}({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Sigma), \\
$$
The unkwown parameters are 
- `\(\boldsymbol\Theta\)`, the matrix of regression parameters
- `\(\boldsymbol\Sigma\)`, the variance-covariance matrix

.footnote[
[1] Single values are also accepted and automatically recycled to full length-vectors.
]

--

When all individuals `\(i=1,\dots,n\)` are stacked together, the data matrices required by the model are

  - the `\(n\times p\)` matrix of counts  `\(\mathbf{Y}\)`
  - the `\(n\times d\)` matrix of design  `\(\mathbf{X}\)`
  - the `\(n\times p\)` matrix of offsets `\(\mathbf{O}\)`

---

# The PLN function

The `PLN` function works in the same way as `lm`: 


```r
PLN(formula = , # mandatory
    data    = , # highly recommended
    subset    , # optional  
    weights   , # optional 
    control     # optional, mostly for advanced users
    )
```

- `data` specifies where to look for the variables
- `formula` specifies the relationship between variables in `data`

  ( `\(\rightsquigarrow\)` _It builds matrices_ `\(\mathbf{Y},\mathbf{X},\mathbf{O}\)`)

--

- `subset` is used for subsampling the observations, it should be a .important[full length] boolean vector, not a vector of indices / sample names
- `weights` is used to weighting the observations, 
- `control` is (mainly) used for tuning the optimization and should typically not be changed.
---

# Simple PLN models on mollusc data (I)

The simplest model we can imagine only has an intercept term:


```r
M00_mollusc &lt;- PLN(Abundance ~ 1, mollusc)
```

`M00_mollusc` is a particular `R` object with class `PLNfit` that comes with a couple methods, helpfully listed when you print the object :


```r
M00_mollusc
```

```
## A multivariate Poisson Lognormal fit with full covariance model.
## ==================================================================
##  degrees_freedom    loglik      BIC       ICL R_squared
##              560 -3634.067 -5053.36 -13800.65 0.9788567
## ==================================================================
## * Useful fields 
##     $model_par, $latent, $var_par, $optim_par 
##     $loglik, $BIC, $ICL, $loglik_vec, $degrees_freedom, $criteria 
## * Useful S3 methods
##     print(), coef(), vcov(), fitted(), predict(), standard_error(), fisher()
```

---

# Accessing parameters: coefficients


```r
coef(M00_mollusc) %&gt;% head() %&gt;% t() %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bit &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Vap &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Vac &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Gac &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Raa &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Rap &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; (Intercept) &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.5910263 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5.108065 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.3348884 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2.190636 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2.518615 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -7.283385 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


```r
M00_mollusc$criteria %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; degrees_freedom &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3634.067 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5053.36 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13800.65 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9788567 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Try accessing some other fields!

---

# Accessing parameters: covariance

.pull-left[

```r
corrplot(
  vcov(M00_mollusc),
  is.corr = FALSE, tl.cex = .5
)
```

![](mollusk_files/figure-html/simple PLN covariance-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
corrplot(
  cov2cor(vcov(M00_mollusc)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/simple PLN correlation-1.png)&lt;!-- --&gt;
]

---
# Playing with offsets

Let us try the Total sum of count for offset, and the sampling duration:


```r
M01_mollusc &lt;- PLN(Abundance ~ 1 + offset(log(Offset)) , mollusc)
M02_mollusc &lt;- PLN(Abundance ~ 1 + offset(log(duration)), mollusc)
```

We then compare the models regarding their criteria:


```r
rbind(
  M00 = M00_mollusc$criteria,
  M01 = M01_mollusc$criteria, 
  M02 = M02_mollusc$criteria) %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; degrees_freedom &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M00 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3634.067 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5053.360 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13800.65 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9788567 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M01 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3593.202 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5012.495 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13927.45 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9648182 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3651.196 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5070.489 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13908.51 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9795608 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

_What do think?_

---

# Adding covariates: site effect (I)

The covariate `site` has 8 levels indicating the sampling site, 


```r
table(mollusc$site)
```

```
## 
## GGravier1 GGravier2 GGravier3     Meant   Negria1   Negria2 Pecheurs1 
##        21        16        18         8        24        24        24 
## Pecheurs2 
##        24
```

--

We would like to account for this covariate, as a natural candidate for explaining a part of the variance which is not very interesting regarding the interactions between species&lt;sup&gt;1&lt;/sup&gt;:



```r
M11_mollusc &lt;- PLN(Abundance ~ 0 + site + offset(log(Offset)), mollusc)
```

Note the use of `0 + ` in the formula so that each parameter associated with the categorical variable corresponds to a mean effect in each modality (remember one-way ANOVA from school).

---
# Adding covariates: site effect (II)

There is a clear gain in introducing this covariate in the model:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; degrees_freedom &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M01 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3593.202 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5012.495 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13927.45 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9648182 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M11 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 784 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2899.770 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4886.781 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11479.57 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.8920388 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

--

However, looking at the coefficients `\(\mathbf{\Theta}\)` associated with `site`, some modalities may be regrouped, hoping for a gain in statistical power/efficiency:

![](mollusk_files/figure-html/site matrix plot-1.png)&lt;!-- --&gt;

---

# Adding covariates (III)

So let us regroup the "Gravier" modalities and the "Negria" and adjust a model

```r
mollusc &lt;- mollusc %&gt;% 
  mutate(site_new = 
    fct_collapse(site, 
      Gravier = c("GGravier1", "GGravier2", "GGravier3"),
      Negria  = c("Negria1", "Negria2")
    )
  )
M21_mollusc &lt;- PLN(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc)
```

--

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; degrees_freedom &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M11 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 784 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2899.770 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4886.781 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11479.57 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.8920388 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M21 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 688 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3019.726 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4763.429 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11974.22 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9096246 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

`\(\rightsquigarrow\)` There is a little loss in terms of loglikelihood, but the BIC choses the latter model.

---

class: inverse, center, middle

# Dimension reduction and vizualisation with PLNPCA

---
# Poisson Lognormal model for PCA

The PLN-PCA model implemented in *PLNmodels* can viewed as a PLN model with an additional rank constraint on the covariance matrix `\(\boldsymbol\Sigma\)` such that `\(\mathrm{rank}(\boldsymbol\Sigma)= q\)`:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta,\boldsymbol\Sigma), &amp; \boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\top \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$`

The dimension of the latent space `\(q\)` corresponds to the number of axes in the PCA or, in other words, to the rank of `\(\boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\intercal\)`.


The unkwown parameters are 
- `\(\boldsymbol\Theta\)`, the matrix of regression parameters
- `\(\mathbf{B}\)`, the matrix of _rescaled loadings_

---
# The PLNPCA function

The `PLNPCA` function works in the same way as the `PLN` function. 

There is just an additional parameter to control the successive value of the ranks to be considered:


```r
PLNPCA(formula = ,   # mandatory
       data    = ,   # highly recommended
       subset    ,   # optional  
       weights   ,   # optional 
*      ranks   = 1:5 # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `ranks` is a vector of rank to be considered
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization

&lt;br/&gt;

`\(\rightsquigarrow\)` The output is a .important[collection of objects], one per rank, all with class `PLNPCAfit`.

---
# A PCA analysis of the mollusc data set

Let us fit PLNPCA on our best model up to now (with TSS as offsets):


```r
PCA_offset &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), mollusc, ranks = 1:8)
```

--

The ouput is of class (`PLNPCAfamily`). It a collection of `R` objects:


```r
PCA_offset
```

```
## --------------------------------------------------------
## COLLECTION OF 8 POISSON LOGNORMAL MODELS
## --------------------------------------------------------
##  Task: Principal Component Analysis
## ========================================================
##  - Ranks considered: from 1 to 8 
##  - Best model (regarding BIC): rank = 6 - R2 = 0.93 
##  - Best model (regarding ICL): rank = 5 - R2 = 0.91
```

`PLNPCAfamily` has three methods: `plot`, `getModel`, `getBestModel`&lt;sup&gt;1&lt;/sup&gt; 

.footnote[[1] Additional help can be found with `?PLNPCAfamily`, `?getBestModel.PLNPCAfamily`, `?plot.PLNPCAfamily`]

---
# PCA analysis: model selection (I)

The plot function gives you hints about the "right" rank/subspace size of your data


```r
plot(PCA_offset)
```

![](mollusk_files/figure-html/plot PLNPCA offset-1.png)&lt;!-- --&gt;

---
# PCA analysis: model selection (II)

To extract a particular model from the collection, use `getBestModel`:


```r
PCA_offset_BIC &lt;- getBestModel(PCA_offset, "BIC")
```

--

The extracted object has class `PLNPCAfit`. It inherits from the `PLNfit` class but with additional methods due to its `PCA` nature: when printing `PCA_offset_BIC`, we get


```
## Poisson Lognormal with rank constrained for PCA (rank = 6)
## ==================================================================
##  degrees_freedom    loglik       BIC       ICL R_squared
##              224 -3498.244 -4065.961 -4242.693 0.9302682
## ==================================================================
## * Useful fields 
##     $model_par, $latent, $var_par, $optim_par 
##     $loglik, $BIC, $ICL, $loglik_vec, $degrees_freedom, $criteria 
## * Useful S3 methods
##     print(), coef(), vcov(), fitted(), predict(), standard_error(), fisher() 
## * Additional fields for PCA
##     $percent_var, $corr_circle, $scores, $rotation 
## * Additional S3 methods for PCA
##     plot.PLNPCAfit()
```

---
# PCA analysis: model exploration

Inheritance allows you to rely on the same methods as with `PLN`:

.pull-left[

```r
corrplot(
  cov2cor(vcov(M01_mollusc)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/PLN covariance M01-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
corrplot(
  cov2cor(vcov(PCA_offset_BIC)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/PLNPCA covariance-1.png)&lt;!-- --&gt;
]

---
# PCA: vizualisation 

The whole point of PCA is vizualisation via dimension reduction.

.pull-left[

```r
plot(PCA_offset_BIC,
  ind_col = mollusc$site,
  nb_axes = 2)
```

&lt;img src="mollusk_files/figure-html/PCA offset vizu site-1.png" style="display: block; margin: auto;" /&gt;
]

.pull-right[

```r
plot(PCA_offset_BIC, 
  ind_col = mollusc$site_new,
  nb_axes = 2)
```

&lt;img src="mollusk_files/figure-html/PCA offset vizu site_new-1.png" style="display: block; margin: auto;" /&gt;
]

---
# PCA: removing covariate effects

To hopefully find some hidden effects in the data, we can try to remove confounding ones:


```r
PCA_s &lt;- PLNPCA(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc, ranks = 1:8)
```

&lt;img src="mollusk_files/figure-html/PCA covariate site plot-1.png" style="display: block; margin: auto;" /&gt;

---
# PCA: refinements in plotting (I)


```r
plot(PCA_offset_BIC,  map = "individual", 
  ind_col = mollusc$site, main = "my individual map")
```

&lt;img src="mollusk_files/figure-html/plot individual-1.png" style="display: block; margin: auto;" /&gt;

---
# PCA: refinements in plotting (II)


```r
plot(PCA_offset_BIC,  map = "variable", main = "my correlation circle")
```

&lt;img src="mollusk_files/figure-html/plot correlation ircle-1.png" style="display: block; margin: auto;" /&gt;

---

class: inverse, center, middle

# Discriminant Analysis for counts with PLNLDA

---

# Poisson Discriminant Analysis

In the vein of Fisher and Rao, we introduce a multi-class LDA model for multivariate count data which can viewed as a PLN model with a discrete group structure in the latent Gaussian space:

The PLN-LDA model assumes a discrete structure with `\(K\)` groups in the following way: the different parameters `\({\boldsymbol\mu}_k \in\mathbb{R}^p\)` corresponds to the group-specific main effects and the variance matrix `\(\boldsymbol{\Sigma}\)` is shared among groups:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta + {\boldsymbol\mu}_i,\boldsymbol\Sigma) &amp; \boldsymbol{\mu}_i = \mathbf{g}_i^\top \mathbf{M} \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$`

where, `\(\mathbf{M} = [\boldsymbol{\mu}_1^\top, \dots, \boldsymbol{\mu}_K^\top]^\top\)` is a `\(K \times p\)` matrix collecting the group-specific main effects, and `\(\mathbf{g}_i\)` is a group-indicator vector of length `\(K\)` 

$$ g_{ik} = 1 \Leftrightarrow g_i = k $$

The unkwown parameters are 
- `\(\boldsymbol\Theta\)`, the matrix of regression parameters
- `\(\mathbf{M}\)`, the matrix containing the `\(K\)` vectors of group means
- `\(\boldsymbol{\Sigma}\)`, the mvariance-covariance matrix

---
# The PLNLDA function

The `PLNLDA` function works in the same way as `PLN`. 

There is just an additional parameter to for the vector of groups on which the discriminant rule is built:


```r
PLNLDA(formula = , # mandatory
       data    = , # highly recommended
       subset    , # optional  
       weights   , # optional 
*      grouping  , # mandatory
       control     # optional
  )
```

- `grouping` is a factor of group (or classification) to be considered

---

# LDA of the mollusc data set: site (I)

Let us try a PLN-LDA on the `site_new` variable:


```r
LDA_site &lt;- PLNLDA(
  Abundance ~ 1 + offset(log(Offset)), mollusc, 
    grouping = mollusc$site_new)
```

.important[Note] The intercept (`1 + `) is automatically removed from the formula to ensure that coefficients and groups can be interpreted as excepted.

--

Contrary to PLNPCA, PLNLDA does not need no model selection, and has the same cost as a PLN fit. As usual, the printing method gives acces tho the available fields and methods:


```
## Linear Discriminant Analysis for Poisson Lognormal distribution
## ==================================================================
##  degrees_freedom    loglik       BIC       ICL R_squared
##              288 -3019.726 -3749.648 -10960.44 0.9096246
## ==================================================================
## * Useful fields 
##     $model_par, $latent, $var_par, $optim_par 
##     $loglik, $BIC, $ICL, $loglik_vec, $degrees_freedom, $criteria 
## * Useful S3 methods
##     print(), coef(), vcov(), fitted(), predict(), standard_error(), fisher() 
## * Additional fields for LDA
##     $percent_var, $corr_map, $scores, $group_means 
## * Additional S3 methods for LDA
##     plot.PLNLDAfit(), predict.PLNLDAfit()
```

---
# LDA of the mollusc data set: site (II)

The plot function is useful to quickly view if some species separates well the groups:


```r
plot(LDA_site, nb_axes = 2)
```

&lt;img src="mollusk_files/figure-html/PLNLDA site plot-1.png" style="display: block; margin: auto;" /&gt;

---
# LDA of the mollusc data set: season

PLN-LDA works also very well for season, with or with correction of the `site effect`:


```r
LDA_season1 &lt;- PLNLDA(Abundance ~ 1 + offset(log(Offset)), 
  mollusc, grouping = mollusc$season)

LDA_season2 &lt;- PLNLDA(Abundance ~ 1 + site_new + offset(log(Offset)), 
  mollusc, grouping = mollusc$season)
```

.pull-left[
![](mollusk_files/figure-html/plot season1-1.png)&lt;!-- --&gt;
]

.pull-right[
![](mollusk_files/figure-html/plot season2-1.png)&lt;!-- --&gt;
]

---
# LDA of the mollusc data set: prediction

If abundance data for new data are avalaible, their group can be predicted using the `predict` function. We illustrate this on our sample&lt;sup&gt;1&lt;/sup&gt; and compare predicted seasons to actual ones


```r
predictions &lt;- predict(LDA_season2, newdata = mollusc, type = "response")
table(predictions, mollusc$season)
```

```
##            
## predictions automn spring summer winter
##      automn     33      1      5      2
##      spring      2     28      5      1
##      summer      6     12     34      4
##      winter      0      2      0     24
```

.footnote[
[1] Predicting the season of samples used to train the model is bad practice in general and prone to overfitting, we do it for illustrative purposes only. 
]

---

class: center, middle, inverse

# Sparse structure estimation with PLNnetwork

---

# Sparse precision for multivariate counts

The PLN-network model for multivariate count data is a variant of PLN where we add a sparsity constraint on the inverse covariance matrix `\({\boldsymbol\Sigma}^{-1}\triangleq \boldsymbol\Omega\)` by means of the `\(\ell_1\)`-norm, such that `\(\|\boldsymbol\Omega\|_1 &lt; c\)`:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}\left({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Omega^{-1}\right) &amp;  \|\boldsymbol\Omega\|_1 &lt; c \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right)
  \end{array}$$`

&lt;br/&gt;

- The `\(\ell_1\)`-penalty on `\(\boldsymbol\Omega\)` induces sparsity and selection of important direct relationships between entities. &lt;br/&gt;

- Hence, the support of `\(\boldsymbol\Omega\)` correspond to a network of underlying interactions. &lt;br /&gt;

- The sparsity level (letter `\(c\)` in the above mathematical model), related to the number of edges in the network, is controlled by a penalty parameter in the optimization process sometimes referred to as `\(\lambda\)`.


---

# The PLNnetwork function

The `PLNnetwork` function works in the same way as `PLN`.

There is just an additional parameter to control the successive values of the sparsity contraint ($\leftrightarrow$ density of the graph):


```r
PLNnetwork(formula = ,  # mandatory
           data    = ,  # highly recommended
           subset    ,  # optional  
           weights   ,  # optional 
*          penalties ,  # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `penalties` is a vector controlling the successively applied sparsity constraints
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization


`\(\rightsquigarrow\)` The algorithm finds a penalty inducing an empty network and goes along the penalties levels, adding edges stepwisely.

---
# Controlling the range of visited networks

The range and size of the vector `penalties` may be controlled via `control_init`. For example,


```r
my_control &lt;- list(
  nPenalties = 40, # more penalties = more networks
  min.ratio = 1e-2 # the smaller, the denser the final network
)

PLNnetwork(formula, mydata,
* control_init = my_control
)
```

Be careful as 
- more networks means more computation
- denser networks means more computation, and less statistical significance !

---
# Network inference on the mollusc data set

We try inference of two collections of networks, with or without accounting for the site effect.


```r
networks_mollusc &lt;- 
  PLNnetwork(
    Abundance ~ 1 + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```


```r
networks_mollusc_site &lt;- 
  PLNnetwork(
    Abundance ~ 0 + site_new + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```

---
# PLNnetwork: Model selection

Just like PLN-PCA, PLNnetwork produces a `PLNnetworkfamily` collection of models with class `PLNnetworkfit`. The models are indexed by the sparsity level (or penalty). The plot function helps in choosing an appropriate level of penalty: 

.pull-left[
![](mollusk_files/figure-html/plot network family-1.png)&lt;!-- --&gt;
]

.pull-right[
![](mollusk_files/figure-html/plot network family site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: field access

Let us plot the residuals covariance matrices, after regularization of its inverse
.pull-left[

```r
net1 &lt;- getBestModel(networks_mollusc)
corrplot(vcov(net1),
  cl.pos = "n", is.corr = FALSE)
```

![](mollusk_files/figure-html/plot covariance-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
net2 &lt;- getBestModel(networks_mollusc_site)
corrplot(vcov(net2),
  cl.pos = "n", is.corr = FALSE)
```

![](mollusk_files/figure-html/plot network site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: network specific functions 

**PLNmodels** brings additional plotting functions dedicated to network.

`\(\rightsquigarrow\)` The `site` effect was masking the relevant interactions.

.pull-left[

```r
plot(net1)
```

![](mollusk_files/figure-html/plot net-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
plot(net2)
```

![](mollusk_files/figure-html/plot net site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: stability selection

An alternative to model selection criteria is the stability selection  - or StARS in the context of network.

- Basically, it uses resampling to estimate robustness of each edges in the network.
- we keep the value of the penalty that guarantees a given level of robustness in the whole network

.important[Careful!]: its is computationally expensive.

--

In `getBestModel`, when "StARS" is requested, stabiltiy selection is performed if needed:


```r
net3 &lt;- getBestModel(networks_mollusc_site, "StARS") 
```
    </textarea>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
