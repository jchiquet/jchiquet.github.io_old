<!DOCTYPE html>
<html>
  <head>
    <title>PLNmodels</title>
    <meta charset="utf-8">
    <meta name="author" content="J. Chiquet, M. Mariadassou, S. Robin   INRA - Applied Mathematics and Informatics Division   Last update 26 March, 2019" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/jquery/jquery.min.js"></script>
    <link href="libs/datatables-css/datatables-crosstalk.css" rel="stylesheet" />
    <script src="libs/datatables-binding/datatables.js"></script>
    <link href="libs/dt-core/css/jquery.dataTables.min.css" rel="stylesheet" />
    <link href="libs/dt-core/css/jquery.dataTables.extra.css" rel="stylesheet" />
    <script src="libs/dt-core/js/jquery.dataTables.min.js"></script>
    <link href="libs/crosstalk/css/crosstalk.css" rel="stylesheet" />
    <script src="libs/crosstalk/js/crosstalk.min.js"></script>
    <link rel="stylesheet" href="pln.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# PLNmodels
## A collection of Poisson lognormal models <br/> for multivariate analysis of count data
### J. Chiquet, M. Mariadassou, S. Robin<br /><br /> <small>INRA - Applied Mathematics and Informatics Division</small> <br /> <small>Last update 26 March, 2019</small>
### <br/><a href="https://jchiquet.github.io/PLNmodels" class="uri">https://jchiquet.github.io/PLNmodels</a>

---






class: inverse, center, middle

# Getting Started

---
# Requirements

## Package PLNmodels

You can install the last release of **PLNmodels** from GitHub:


```r
devtools::install_github("jchiquet/PLNmodels")
```

## Dependencies

Make sure the following CRAN and BioConductor packages are installed:


```r
required_CRAN &lt;- c("R6", "glassoFast", "Matrix", "Rcpp", "RcppArmadillo",
                   "nloptr", "igraph", "grid", "gridExtra", "dplyr",
                   "tidyr", "ggplot2", "corrplot", "magrittr", "devtools")
required_BioC &lt;- c("phyloseq", "biomformat")

not_installed_CRAN &lt;- setdiff(required_CRAN, rownames(installed.packages()))
if (length(not_installed_CRAN) &gt; 0) install.packages(not_installed_CRAN)

not_installed_BioC &lt;- setdiff(required_BioC, rownames(installed.packages()))
if (length(not_installed_BioC) &gt; 0) BiocManager::install(not_installed_BioC)
```

---

# First steps

## Loading the package

Check that the installation process succeeded


```r
library(PLNmodels)
packageVersion("PLNmodels")
```

```
## [1] '0.9.1.9000'
```

## Finding help and documentation

The [PLNmodels website](https://jchiquet.github.io/PLNmodels/) contains

- the standard package documentation 
- a set of comprehensive vignettes for the top-level functions

all formatted with [**pkgdown**](https://pkgdown.r-lib.org)


And do not forget `?`/`??` in the `R` console.

---

class: inverse, center, middle

# 'Mollusk' &lt;br/&gt; A motivating companion data set &lt;br/&gt; .small[See Richardot-Coulet, Chessel, and Bournaud [RCB86]]


---

# Generic form of data sets
  
Routinely gathered in ecology/microbiology/genomics 

## Data tables

  - .important[Abundances]: read counts of species/transcripts `\(j\)` in sample `\(i\)`
  - .important[Covariates]: value of environmental variable `\(k\)` in sample `\(i\)`
  - .important[Offsets]: sampling effort for species/transcripts `\(j\)` in sample `\(i\)`

## Need for multivariate analysis

  - exhibit .important[patterns of diversity] &lt;br/&gt;
      `\(\rightsquigarrow\)` summarize the information  (PCA, clustering, `\(\dots\)`)
  - understand .important[between-species interactions] &lt;br /&gt;
      `\(\rightsquigarrow\)` 'network' inference (variable/covariance selection)
  - correct for technical and .important[confounding effects] &lt;br/&gt;
      `\(\rightsquigarrow\)` account for covariables and sampling effort

`\(\rightsquigarrow\)` need a generic framework to _model dependences between count variables_

---

# 'mollusk' data set overview

&lt;br/&gt;

The `mollusk` variable is loaded by the function `data()`. 

```r
data(mollusk)
```

It consists in a list of two data frames, typical from ecological data sets

- The `abundance` table contains the counts of 32 species in 163 samples; 
- The `covariate` table contains information about 4  environmental variables.


```r
str(mollusk, max.level = 1)
```

```
## List of 2
##  $ Abundance:'data.frame':	163 obs. of  32 variables:
##  $ Covariate:'data.frame':	163 obs. of  4 variables:
```

&lt;br/&gt;

Have a look at the help page with `?mollusk` to get additional details.

---

# Abundance table (I)


```r
mollusk$Abundance %&gt;% 
  dplyr::select(1:10) %&gt;% 
  head() %&gt;% DT::datatable(fillContainer = FALSE)
```

<div id="htmlwidget-16dcbbccef0d5a46016a" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-16dcbbccef0d5a46016a">{"x":{"filter":"none","fillContainer":false,"data":[["1","2","3","4","5","6"],[2,2,1,13,19,54],[0,0,0,0,0,0],[2,0,0,0,4,3],[0,0,0,0,0,0],[0,2,1,0,0,1],[0,0,0,0,0,0],[0,0,0,0,0,0],[22,93,39,1,2,2],[0,0,0,0,0,0],[0,0,0,0,0,0]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Bit<\/th>\n      <th>Vap<\/th>\n      <th>Vac<\/th>\n      <th>Gac<\/th>\n      <th>Raa<\/th>\n      <th>Rap<\/th>\n      <th>Lit<\/th>\n      <th>Pha<\/th>\n      <th>Phf<\/th>\n      <th>Plc<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6,7,8,9,10]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>

---

# Abundance table (II)


```r
t(log(1 + mollusk$Abundance)) %&gt;% 
  corrplot::corrplot(
    is.corr = FALSE,
    addgrid.col = NA, 
    tl.cex = .5, 
    cl.pos = "n"
  )
```

![](mollusk_files/figure-html/glance Abundances-1.png)&lt;!-- --&gt;

---

# Covariates and offsets

The three first covariates are categorical. The fourth one is numerical.

- `site`: sampling site
- `season`: winter, spring, summer, autumn
- `method`: sampling - wood or string
- `duration`: time of exposure (in week)


```r
summary(mollusk$Covariate)
```

```
##         site       season      method      duration    
##  Negria1  :24   automn:41   string:82   Min.   :3.000  
##  Negria2  :24   spring:44   wood  :81   1st Qu.:3.000  
##  Pecheurs1:24   summer:44               Median :6.000  
##  Pecheurs2:24   winter:34               Mean   :6.129  
##  GGravier3:22                           3rd Qu.:9.000  
##  GGravier1:21                           Max.   :9.000  
##  (Other)  :24
```

`\(\rightsquigarrow\)` `method` and `duration` are candidate for modeling sampling effort as offsets

---

# Data preparation

In **PLNmodels**, data are handled into a single data frame that put together
1. the counts,
1. the potential covariates,
1. the offset that may be used in the models.

.important[_Important!_]

1. All the species found in the counts table will be used in the model,
2. The formula mechanism of `R` allows you to choose specific covariates or offsets.

--

The helping function `prepare_data` allows you to avoid taking care of cumbersome data manipulation &lt;sup&gt;1&lt;/sup&gt;.


```r
prepare_data(
  counts     = , # your count table
  covariates = , # your covariates
  offset     = , # the method to compute offsets 
                 # or a predefined matrix/vector of offset
)
```

.footnote[
[1] variants of `prepare_data` exist for [`biom`](http://biom-format.org/) file and objects build using the [`phyloseq`](https://joey711.github.io/phyloseq/) BioConductor package.
]
---

# Preparing the mollusk data set 

We choose here to consider the total sum of counts to build our vector of offsets


```r
mollusc &lt;- prepare_data(
    counts = mollusk$Abundance,
    covariates = mollusk$Covariate, 
*   offset = "TSS"  # look at other possible choices
  )
```

--

The structure of the final object is a data frame&lt;sup&gt;1&lt;/sup&gt;, but with some columns filled with matrices:


```r
str(mollusc, max.level = 1)
```

```
## 'data.frame':	159 obs. of  6 variables:
##  $ Abundance: int [1:159, 1:32] 2 2 1 13 19 54 32 6 24 15 ...
##   ..- attr(*, "dimnames")=List of 2
##  $ site     : Factor w/ 8 levels "GGravier1","GGravier2",..: 5 5 5 5 5 5 5 5 5 5 ...
##  $ season   : Factor w/ 4 levels "automn","spring",..: 4 4 4 2 2 2 3 3 3 1 ...
##  $ method   : Factor w/ 2 levels "string","wood": 2 2 2 2 2 2 2 2 2 2 ...
##  $ duration : num  3 6 9 3 6 9 3 6 9 3 ...
##  $ Offset   : num  83 203 93 18 41 96 174 22 104 88 ...
```

.footnote[
[1] Note that `mollusc` has 3 fewer samples than `mollusk`, as `prepare_data` automatically removed empty samples.
]

---

class: inverse, center, middle

# Multivariate Poisson lognormal models &lt;br/&gt; statistical framework

---

# Models for multivariate count data

## If we were in a Gaussian world...

The .important[general linear model] [MKB79] would be appropriate! For each sample `\(i = 1,\dots,n\)`, 

`$$\underbrace{\mathbf{Y}_i}_{\text{abundances}} =  \underbrace{\mathbf{X}_i \boldsymbol\Theta}_{\text{covariates}} + \underbrace{\mathbf{O}_i}_{\text{sampling effort}} + \boldsymbol\varepsilon_i, \quad \boldsymbol\varepsilon_i \sim \mathcal{N}(\mathbf{0}_p, \underbrace{\boldsymbol\Sigma}_{\text{between-species dependencies}})$$`

null covariance `\(\Leftrightarrow\)` independence `\(\rightsquigarrow\)` uncorrelated species/transcripts do not interact

`\(\rightsquigarrow\)` This model gives birth to Principal Component Analysis,  Discriminant Analysis, Gaussian Graphical Models and many others `\(\dots\)`

--

## With count data...

There is no generic model for multivariate counts

  - Data transformation (log, `\(\sqrt{}\)`) : quick and dirty
  - Non-Gaussian multivariate distributions [Ino+17]: do not scale to data dimension yet
  - .important[Latent variable models]: interaction occur in a latent (unobserved) layer

---

# The Poisson Lognormal model (PLN)

The PLN model [AH89] is a .important[multivariate generalized linear model], where 

- the counts `\(\mathbf{Y}_i\)` are the response variables
- the main effect is due to a linear combination of the covariates `\(\mathbf{x}_i\)`
- a vector of offsets `\(\mathbf{o}_i\)` can be specified for each sample.

$$
\mathbf{Y}_i | \mathbf{Z}_i \sim \mathcal{P}\left(\exp\{\mathbf{Z}_i\}\right), \qquad \mathbf{Z}_i \sim \mathcal{N}({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Sigma), \\
$$

.pull-left[The unkwown parameters are 
- `\(\boldsymbol\Theta\)`, the regression parameters
- `\(\boldsymbol\Sigma\)`, the variance-covariance matrix
]

.pull-right[
PLN has some expected properties
- over-dispersion
- covariance with arbitrary signs
]

--

When all individuals `\(i=1,\dots,n\)` are together, the data matrices required are
  - the `\(n\times p\)` matrix of counts  `\(\mathbf{Y}\)`
  - the `\(n\times d\)` matrix of design  `\(\mathbf{X}\)`
  - the `\(n\times p\)` matrix of offsets `\(\mathbf{O}\)`

---
# Geometrical view

![](mollusk_files/figure-html/PLN geometry-1.png)&lt;!-- --&gt;

---
# .small[Inference: latent model but intractable EM]
  
## Aim of the inference

  - estimate `\(\theta = (\boldsymbol\Theta, \boldsymbol\Sigma)\)` 
  - predict the `\(\mathbf{Z}_i\)`

## Maximum likelihood

PLN is an incomplete data model: try EM
`$$\log p_\theta(\mathbf{Y}) = \mathbb{E}_p [\log p_\theta(\mathbf{Y}, \mathbf{Z}) \,|\, \mathbf{Y}] + \mathcal{H}[p_\theta(\mathbf{Z}\,|\,\mathbf{Y})]$$` 

EM requires to evaluate (some moments of) `\(p_\theta(\mathbf{Z} \,|\,  \mathbf{Y})\)`, but there is no close form!

## Solutions

  - [AH89] resort on numerical integration; [Kar05] Monte-Carlo integration
  - Several heuristics, not always well motivated, found in the literature...
  - .important[Variational approach] [WJ08]: use a proxy of `\(p_\theta(\mathbf{Z}\,|\,\mathbf{Y})\)`.

---
# Variational approach to generalize EM

## Principle 

Choose a convenient class of distribution `\(\mathcal{Q}\)`

`$$\mathcal{Q} = \Big\{\tilde{p}: \quad \tilde{p}(\mathbf{Z}) = \prod_i \tilde{p}_i(\mathbf{Z}_i), \quad \tilde{p}_i(\mathbf{Z}_i) = \mathcal{N}(\mathbf{Z}_i; \tilde{m}_i, \tilde{s}_i) \Big\}$$`

and maximize the following lower bound

`$$J(\theta, \tilde{p}) = \log p_\theta(\mathbf{Y}) - KL[\tilde{p}_\theta (\mathbf{Z}) ||  p_\theta(\mathbf{Z} | \mathbf{Y})]  = \mathbb{E}_{\tilde{p}} [\log p_\theta(\mathbf{Y}, \mathbf{Z})] + \mathcal{H}[\tilde{p}(\mathbf{Z})]$$`

## Variational EM

  - VE step: find the optimal `\(\tilde{p}\)`: 
`$$\tilde{p}^h = \arg \max J(\theta^h, \tilde{p}) = \arg\min_{\tilde{p} \in \mathcal{Q}} KL[\tilde{p}(\mathbf{Z}) \,||\, p_{\theta^h}(\mathbf{Z}\,|\,\mathbf{Y})]$$`
  - M step: update `\(\hat{\theta}^h\)`
`$$\theta^h = \arg\max J(\theta, \tilde{p}^h) = \arg\max_{\theta} \mathbb{E}_{\tilde{p}} [\log p_{\theta}(\mathbf{Y}, \mathbf{Z})]$$`

---
# .small[Application to the optimization of PLN models]
  
## Property of PLN variational approximation

The lower bound `\(J(\theta, \tilde{p})\)` is bi-concave, i.e.
  - wrt `\(\tilde{p} = (\tilde{\mathbf{M}}, \tilde{\mathbf{S}})\)` for given `\(\theta\)` 
  - wrt `\(\theta = (\boldsymbol\Sigma, \boldsymbol\Theta)\)` for given `\(\tilde{p}\)` 
but .important[not jointly concave] in general.

## Optimization

projected gradient ascent for the complete set of parameters&lt;sup&gt;1&lt;/sup&gt; `\((\tilde{\mathbf{M}}, \tilde{\mathbf{S}}, \theta)\)`

  - **algorithm**: conservative convex separable approximations Svanberg [Sva02] &lt;br/&gt;
  - **implementation**: `NLopt` nonlinear-optimization library Johnson [Joh11] &lt;br/&gt;
  - **initialization**: LM after log-trasnformation applied independently on each variables + concatenation of the regression coefficients + Pearson residuals

.footnote[[1] Alternating between varitional and model parameters is useless here]

---

class: inverse, center, middle

# Multivariate Poisson Regression with PLN

---

# The PLN function

The `PLN` function works in the same way as `lm`: 


```r
PLN(formula = , # mandatory
    data    = , # highly recommended
    subset    , # optional  
    weights   , # optional 
    control     # optional, mostly for advanced users
    )
```

- `data` specifies where to look for the variables
- `formula` specifies the relationship between variables in `data`

  ( `\(\rightsquigarrow\)` _It builds matrices_ `\(\mathbf{Y},\mathbf{X},\mathbf{O}\)`)

--

- `subset` is used for subsampling the observations, it should be a .important[full length] boolean vector, not a vector of indices / sample names
- `weights` is used to weighting the observations, 
- `control` is (mainly) used for tuning the optimization and should typically not be changed.
---

# Simple PLN models on mollusc data (I)

The simplest model we can imagine only has an intercept term:


```r
M00_mollusc &lt;- PLN(Abundance ~ 1, mollusc)
```

`M00_mollusc` is a particular `R` object with class `PLNfit` that comes with a couple methods, helpfully listed when you print the object :


```r
M00_mollusc
```

```
## A multivariate Poisson Lognormal fit with full covariance model.
## ==================================================================
##  nb_param    loglik       BIC       ICL R_squared
##       560 -3634.142 -5053.435 -13799.86     0.979
## ==================================================================
## * Useful fields
##     $model_par, $latent, $var_par, $optim_par
##     $loglik, $BIC, $ICL, $loglik_vec, $nb_param, $criteria
## * Useful S3 methods
##     print(), coef(), sigma(), vcov(), fitted(), predict(), standard_error()
```

---

# Accessing parameters: coefficients


```r
coef(M00_mollusc) %&gt;% head() %&gt;% t() %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bit &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Vap &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Vac &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Gac &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Raa &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Rap &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; (Intercept) &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.5969453 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5.104882 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.339746 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2.199856 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2.506255 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -7.293509 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


```r
M00_mollusc$criteria %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; nb_param &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3634.142 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5053.435 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13799.86 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9788534 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Try accessing some other fields!

---

# Accessing parameters: covariance

.pull-left[

```r
corrplot(
  sigma(M00_mollusc),
  is.corr = FALSE, tl.cex = .5
)
```

![](mollusk_files/figure-html/simple PLN covariance-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
corrplot(
  cov2cor(sigma(M00_mollusc)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/simple PLN correlation-1.png)&lt;!-- --&gt;
]

---
# Playing with offsets

Let us try the Total sum of count for offset, and the sampling duration:


```r
M01_mollusc &lt;- PLN(Abundance ~ 1 + offset(log(Offset)) , mollusc)
M02_mollusc &lt;- PLN(Abundance ~ 1 + offset(log(duration)), mollusc)
```

We then compare the models regarding their criteria:


```r
rbind(
  M00 = M00_mollusc$criteria,
  M01 = M01_mollusc$criteria, 
  M02 = M02_mollusc$criteria) %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; nb_param &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M00 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3634.142 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5053.435 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13799.86 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9788534 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M01 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3593.162 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5012.455 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13924.75 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9648186 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M02 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3651.095 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5070.389 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13910.62 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9795718 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

_What do you think?_

---

# Adding covariates: site effect (I)

The covariate `site` has 8 levels indicating the sampling site, 


```r
table(mollusc$site)
```

```
## 
## GGravier1 GGravier2 GGravier3     Meant   Negria1   Negria2 Pecheurs1 
##        21        16        18         8        24        24        24 
## Pecheurs2 
##        24
```

--

We would like to account for this covariate, as a natural candidate for explaining a part of the variance which is not very interesting regarding the interactions between species&lt;sup&gt;1&lt;/sup&gt;:



```r
M11_mollusc &lt;- PLN(Abundance ~ 0 + site + offset(log(Offset)), mollusc)
```

Note the use of `0 + ` in the formula so that each parameter associated with the categorical variable corresponds to a mean effect in each modality (remember one-way ANOVA from school).

---
# Adding covariates: site effect (II)

There is a clear gain in introducing this covariate in the model:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; nb_param &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M01 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 560 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3593.162 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -5012.455 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -13924.75 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9648186 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M11 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 784 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2899.791 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4886.801 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11484.80 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.8920362 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

--

However, looking at the coefficients `\(\mathbf{\Theta}\)` associated with `site`, some modalities may be regrouped, hoping for a gain in statistical power/efficiency:

![](mollusk_files/figure-html/site matrix plot-1.png)&lt;!-- --&gt;

---

# Adding covariates (III)

So let us regroup the "Gravier" modalities and the "Negria" and adjust a model

```r
mollusc &lt;- mollusc %&gt;% 
  mutate(site_new = 
    fct_collapse(site, 
      Gravier = c("GGravier1", "GGravier2", "GGravier3"),
      Negria  = c("Negria1", "Negria2")
    )
  )
M21_mollusc &lt;- PLN(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc)
```

--

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; nb_param &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; loglik &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; BIC &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; ICL &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; R_squared &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M11 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 784 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -2899.791 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4886.801 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11484.8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.8920362 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; M21 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 688 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -3019.723 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -4763.426 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; -11982.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.9096319 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

`\(\rightsquigarrow\)` There is a little loss in terms of loglikelihood, but the BIC choses the latter model.

---

class: inverse, center, middle

# Dimension reduction and vizualisation with PLNPCA &lt;br/&gt; .small[See Chiquet, Mariadassou, and Robin [CMR18]]

---
# Poisson Lognormal model for PCA

The PLN-PCA [CMR18] model implemented in *PLNmodels* can viewed as a PLN model with an additional rank constraint on the covariance matrix `\(\boldsymbol\Sigma\)` such that `\(\mathrm{rank}(\boldsymbol\Sigma)= q\)`:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta,\boldsymbol\Sigma), &amp; \boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\top \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$`

The dimension of the latent space `\(q\)` corresponds to the number of axes in the PCA or, in other words, to the rank of `\(\boldsymbol\Sigma = \mathbf{B}\mathbf{B}^\intercal\)`.


The unkwown parameters are  `\(\boldsymbol\Theta\)` and `\(\mathbf{B}\)`, the matrix of .important[_rescaled loadings_]

--

### Features

  - **Optimization**: _"Similar"_ variational framework (with different gradients)
  - **Model selection**: variational BIC/ICL
      - `\(\tilde{\text{BIC}}_q = J(\theta, \tilde{p}) - \frac12 p (d + q) \log(n)\)`,  `\(\tilde{\text{ICL}}_q = \tilde{\text{BIC}}_q - \mathcal{H}(\tilde{p})\)`
  - **Vizualization:** PCA on the expected latent position `\(\mathbb{E}_{\tilde{p}}(\mathbf{Z}_i) = \mathbf{M}\hat{\mathbf{B}}^\top\)`

---
# The PLNPCA function

The `PLNPCA` function works in the same way as the `PLN` function. 

There is just an additional parameter to control the successive value of the ranks to be considered:


```r
PLNPCA(formula = ,   # mandatory
       data    = ,   # highly recommended
       subset    ,   # optional  
       weights   ,   # optional 
*      ranks   = 1:5 # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `ranks` is a vector of rank to be considered
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization

&lt;br/&gt;

`\(\rightsquigarrow\)` The output is a .important[collection of objects], one per rank, all with class `PLNPCAfit`.

---
# A PCA analysis of the mollusc data set

Let us fit PLNPCA on our best model up to now (with TSS as offsets):


```r
PCA_offset &lt;- PLNPCA(Abundance ~ 1 + offset(log(Offset)), mollusc, ranks = 1:8)
```

--

The ouput is of class (`PLNPCAfamily`). It a collection of `R` objects:


```r
PCA_offset
```

```
## --------------------------------------------------------
## COLLECTION OF 8 POISSON LOGNORMAL MODELS
## --------------------------------------------------------
##  Task: Principal Component Analysis
## ========================================================
##  - Ranks considered: from 1 to 8
##  - Best model (greater BIC): rank = 6 - R2 = 0.93
##  - Best model (greater ICL): rank = 4 - R2 = 0.87
```

`PLNPCAfamily` has three methods: `plot`, `getModel`, `getBestModel`&lt;sup&gt;1&lt;/sup&gt; 

.footnote[[1] Additional help can be found with `?PLNPCAfamily`, `?getBestModel.PLNPCAfamily`, `?plot.PLNPCAfamily`]

---
# PCA analysis: model selection (I)

The plot function gives you hints about the "right" rank/subspace size of your data


```r
plot(PCA_offset)
```

![](mollusk_files/figure-html/plot PLNPCA offset-1.png)&lt;!-- --&gt;

---
# PCA analysis: model selection (II)

To extract a particular model from the collection, use `getBestModel`:


```r
PCA_offset_BIC &lt;- getBestModel(PCA_offset, "BIC")
```

--

The extracted object has class `PLNPCAfit`. It inherits from the `PLNfit` class but with additional methods due to its `PCA` nature: when printing `PCA_offset_BIC`, we get


```
## Poisson Lognormal with rank constrained for PCA (rank = 6)
## ==================================================================
##  nb_param    loglik       BIC       ICL R_squared
##       224 -3509.055 -4076.773 -4252.794      0.93
## ==================================================================
## * Useful fields
##     $model_par, $latent, $var_par, $optim_par
##     $loglik, $BIC, $ICL, $loglik_vec, $nb_param, $criteria
## * Useful S3 methods
##     print(), coef(), sigma(), vcov(), fitted(), predict(), standard_error()
## * Additional fields for PCA
##     $percent_var, $corr_circle, $scores, $rotation
## * Additional S3 methods for PCA
##     plot.PLNPCAfit()
```

---
# PCA analysis: model exploration

Inheritance allows you to rely on the same methods as with `PLN`:

.pull-left[

```r
corrplot(
  cov2cor(sigma(M01_mollusc)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/PLN covariance M01-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
corrplot(
  cov2cor(sigma(PCA_offset_BIC)),
  tl.cex = .5
)
```

![](mollusk_files/figure-html/PLNPCA covariance-1.png)&lt;!-- --&gt;
]

---
# PCA: vizualisation 

The whole point of PCA is vizualisation via dimension reduction.

.pull-left[

```r
plot(PCA_offset_BIC,
  ind_col = mollusc$site,
  nb_axes = 2)
```

&lt;img src="mollusk_files/figure-html/PCA offset vizu site-1.png" style="display: block; margin: auto;" /&gt;
]

.pull-right[

```r
plot(PCA_offset_BIC, 
  ind_col = mollusc$site_new,
  nb_axes = 2)
```

&lt;img src="mollusk_files/figure-html/PCA offset vizu site_new-1.png" style="display: block; margin: auto;" /&gt;
]

---
# PCA: removing covariate effects

To hopefully find some hidden effects in the data, we can try to remove confounding ones:


```r
PCA_s &lt;- PLNPCA(Abundance ~ 0 + site_new + offset(log(Offset)), mollusc, ranks = 1:8)
```

&lt;img src="mollusk_files/figure-html/PCA covariate site plot-1.png" style="display: block; margin: auto;" /&gt;

---
# PCA: refinements in plotting (I)


```r
plot(PCA_offset_BIC,  map = "individual", 
  ind_col = mollusc$site, main = "my individual map")
```

&lt;img src="mollusk_files/figure-html/plot individual-1.png" style="display: block; margin: auto;" /&gt;

---
# PCA: refinements in plotting (II)


```r
plot(PCA_offset_BIC,  map = "variable", main = "my correlation circle")
```

&lt;img src="mollusk_files/figure-html/plot correlation ircle-1.png" style="display: block; margin: auto;" /&gt;

---

class: inverse, center, middle

# Discriminant Analysis for counts with PLNLDA

---

# Poisson Discriminant Analysis

In the vein of Fisher and Rao, we introduce a multi-class LDA model for multivariate count data which can viewed as a PLN model with a discrete group structure in the latent Gaussian space:

The PLN-LDA model assumes a discrete structure with `\(K\)` groups in the following way: the different parameters `\({\boldsymbol\mu}_k \in\mathbb{R}^p\)` corresponds to the group-specific main effects and the variance matrix `\(\boldsymbol{\Sigma}\)` is shared among groups:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}(\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta + {\boldsymbol\mu}_i,\boldsymbol\Sigma) &amp; \boldsymbol{\mu}_i = \mathbf{g}_i^\top \mathbf{M} \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right),
\end{array}$$`

where, `\(\mathbf{M} = [\boldsymbol{\mu}_1^\top, \dots, \boldsymbol{\mu}_K^\top]^\top\)` is a `\(K \times p\)` matrix collecting the group-specific main effects, and `\(\mathbf{g}_i\)` is a group-indicator vector of length `\(K\)` 

$$ g_{ik} = 1 \Leftrightarrow g_i = k $$

The unkwown parameters are 
- `\(\boldsymbol\Theta\)`, the matrix of regression parameters
- `\(\mathbf{M}\)`, the matrix containing the `\(K\)` vectors of group means
- `\(\boldsymbol{\Sigma}\)`, the variance-covariance matrix

---
# Geometrical view

![](mollusk_files/figure-html/PLN_geom_lda_no_offset-1.png)&lt;!-- --&gt;

---
# PLNLDA: principles

## Inference

1. Adjust a "standard" PLN with `\(\mathbf{X} \rightarrow (\mathbf{X}, \mathbf{G})\)`,  `\(\boldsymbol\Theta \rightarrow (\boldsymbol\Theta, \mathbf{U})\)`

2. Use estimate `\(\boldsymbol\Sigma, \mathbf{U}\)` and `\(\boldsymbol\Theta\)` and `\(\tilde{\mathbf{Z}}_i\)` to compute
`$$\hat{\boldsymbol\Theta} = \frac1{K-1} \sum_k n_k (\hat{\boldsymbol\mu}_k - \hat{\boldsymbol\mu}_\bullet) (\hat{\boldsymbol\mu}_k - \hat{\boldsymbol\mu}_\bullet)^\intercal$$`
  - Compute first `\(K-1\)` eigenvectors of `\(\hat{\boldsymbol\Sigma}^{-1} \hat{\boldsymbol\Theta} = \mathbf{P}^\top \Lambda \mathbf{P}\)` (discriminant axes)

## Features

  - **Graphical representation**:  `\(\tilde{\mathbf{Z}} \mathbf{P} \Lambda^{1/2}\)`, the coordinates along the discriminant axes
  - **Prediction**: For each group, 
    - Compute (variational) likelihood `\(p_k = P(\mathbf{Y}_{\text{new}} | \hat{\boldsymbol\Sigma}, \hat{\boldsymbol\Theta}, \hat{\boldsymbol\mu}_k)\)`
    - Assign `\(i\)` to group with highest posterior probability `\(\pi_k \propto \frac{n_k p_k}{n}\)`
  
---
# The PLNLDA function

The `PLNLDA` function works in the same way as `PLN`. 

There is just an additional parameter to for the vector of groups on which the discriminant rule is built:


```r
PLNLDA(formula = , # mandatory
       data    = , # highly recommended
       subset    , # optional  
       weights   , # optional 
*      grouping  , # mandatory
       control     # optional
  )
```

- `grouping` is a factor of group (or classification) to be considered

---

# LDA of the mollusc data set: site (I)



Let us try a PLN-LDA on the `site` variable&lt;sup&gt;1&lt;/sup&gt;:


```r
LDA_site &lt;- PLNLDA(
  Abundance ~ offset(log(Offset)), data = mollusc, grouping = site_new)
```

--

Contrary to PLNPCA, PLNLDA does not need no model selection, and has the same cost as a PLN fit. As usual, the printing method gives acces tho the available fields and methods:


```
## Linear Discriminant Analysis for Poisson Lognormal distribution
## ==================================================================
##  nb_param    loglik       BIC       ICL R_squared
##       288 -3019.723 -3749.645 -10968.52      0.91
## ==================================================================
## * Useful fields
##     $model_par, $latent, $var_par, $optim_par
##     $loglik, $BIC, $ICL, $loglik_vec, $nb_param, $criteria
## * Useful S3 methods
##     print(), coef(), sigma(), vcov(), fitted(), predict(), standard_error()
## * Additional fields for LDA
##     $percent_var, $corr_map, $scores, $group_means
## * Additional S3 methods for LDA
##     plot.PLNLDAfit(), predict.PLNLDAfit()
```

---
# LDA of the mollusc data set: site (II)

The plot function is useful to quickly view if some species separates well the groups:


```r
plot(LDA_site)
```

&lt;img src="mollusk_files/figure-html/PLNLDA site plot-1.png" style="display: block; margin: auto;" /&gt;

---
# LDA of the mollusc data set: season

PLN-LDA works also very well for season, with or with correction of the `site effect`:


```r
LDA_season1 &lt;- PLNLDA(Abundance ~ 1 + offset(log(Offset)), 
  data = mollusc, grouping = season)

LDA_season2 &lt;- PLNLDA(Abundance ~ 1 + site_new + offset(log(Offset)), 
  data = mollusc, grouping = season)
```

.pull-left[
![](mollusk_files/figure-html/plot season1-1.png)&lt;!-- --&gt;
]

.pull-right[
![](mollusk_files/figure-html/plot season2-1.png)&lt;!-- --&gt;
]

---
# LDA of the mollusc data set: prediction

If abundance data for new data are avalaible, their group can be predicted using the `predict` function. We illustrate this on our sample&lt;sup&gt;1&lt;/sup&gt; and compare predicted seasons to actual ones


```r
predictions &lt;- predict(LDA_season2, newdata = mollusc, type = "response")
table(predictions, mollusc$season)
```

```
##            
## predictions automn spring summer winter
##      automn     33      1      5      2
##      spring      2     28      5      1
##      summer      6     12     34      4
##      winter      0      2      0     24
```

.footnote[
[1] Predicting the season of samples used to train the model is bad practice in general and prone to overfitting, we do it for illustrative purposes only. 
]

---

class: center, middle, inverse

# Sparse structure estimation with PLNnetwork &lt;br/&gt; .small[See Chiquet, Mariadassou, and Robin [CMR18]]

---

# Sparse precision for multivariate counts

The PLN-network model for multivariate count data is a variant of PLN where we add a sparsity constraint on the inverse covariance matrix `\({\boldsymbol\Sigma}^{-1}\triangleq \boldsymbol\Omega\)` by means of the `\(\ell_1\)`-norm, such that `\(\|\boldsymbol\Omega\|_1 &lt; c\)`:

`$$\begin{array}{rcl}
  \text{latent space } &amp;   \mathbf{Z}_i \sim \mathcal{N}\left({\mathbf{o}_i + \mathbf{x}_i^\top\boldsymbol\Theta},\boldsymbol\Omega^{-1}\right) &amp;  \|\boldsymbol\Omega\|_1 &lt; c \\
  \text{observation space } &amp;  Y_{ij} | Z_{ij} \quad \text{indep.} &amp; Y_{ij} | Z_{ij} \sim \mathcal{P}\left(\exp\{Z_{ij}\}\right)
  \end{array}$$`

&lt;br/&gt;

- The `\(\ell_1\)`-penalty on `\(\boldsymbol\Omega\)` induces sparsity and selection of important direct relationships between entities. &lt;br/&gt;

- Hence, the support of `\(\boldsymbol\Omega\)` correspond to a network of underlying interactions. &lt;br /&gt;

- The sparsity level (letter `\(c\)` in the above mathematical model), related to the number of edges in the network, is controlled by a penalty parameter in the optimization process sometimes referred to as `\(\lambda\)`.


---

# The PLNnetwork function

The `PLNnetwork` function works in the same way as `PLN`.

There is just an additional parameter to control the successive values of the sparsity contraint ($\leftrightarrow$ density of the graph):


```r
PLNnetwork(formula = ,  # mandatory
           data    = ,  # highly recommended
           subset    ,  # optional  
           weights   ,  # optional 
*          penalties ,  # has default values
       control_init  # optional
       control_main  # optional
  )
```

- `penalties` is a vector controlling the successively applied sparsity constraints
- `control_init` is (mainly) used for tuning the initialization
- `control_main` is (mainly) used for tuning the optimization


`\(\rightsquigarrow\)` The algorithm finds a penalty inducing an empty network and goes along the penalties levels, adding edges stepwisely.

---
# .small[Controlling the range of visited networks]

The range and size of the vector `penalties` may be controlled via `control_init`. For example,


```r
my_control &lt;- list(
  nPenalties = 40, # more penalties = more networks
  min.ratio = 1e-2 # the smaller, the denser the final network
)

PLNnetwork(formula, mydata,
* control_init = my_control
)
```

Be careful as 
- more networks means more computation
- denser networks means more computation, and less statistical significance !

---
# Network inference on the mollusc data set

We try inference of two collections of networks, with or without accounting for the site effect.


```r
networks_mollusc &lt;- 
  PLNnetwork(
    Abundance ~ 1 + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```


```r
networks_mollusc_site &lt;- 
  PLNnetwork(
    Abundance ~ 0 + site_new + offset(log(Offset)),
    data = mollusc, 
    control_init = list(min.ratio = 1e-2)
  )
```

---
# PLNnetwork: Model selection

Just like PLN-PCA, PLNnetwork produces a `PLNnetworkfamily` collection of models with class `PLNnetworkfit`. The models are indexed by the sparsity level (or penalty). The plot function helps in choosing an appropriate level of penalty: 

.pull-left[
![](mollusk_files/figure-html/plot network family-1.png)&lt;!-- --&gt;
]

.pull-right[
![](mollusk_files/figure-html/plot network family site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: field access

Let us plot the residuals covariance matrices, after regularization of its inverse
.pull-left[

```r
net1 &lt;- getBestModel(networks_mollusc)
corrplot(sigma(net1),
  cl.pos = "n", is.corr = FALSE)
```

![](mollusk_files/figure-html/plot covariance-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
net2 &lt;- getBestModel(networks_mollusc_site)
corrplot(sigma(net2),
  cl.pos = "n", is.corr = FALSE)
```

![](mollusk_files/figure-html/plot network site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: network specific functions 

**PLNmodels** brings additional plotting functions dedicated to network.

`\(\rightsquigarrow\)` The `site` effect was masking the relevant interactions.

.pull-left[

```r
plot(net1)
```

![](mollusk_files/figure-html/plot net-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
plot(net2)
```

![](mollusk_files/figure-html/plot net site-1.png)&lt;!-- --&gt;
]

---
# PLNnetwork: stability selection

An alternative to model selection criteria is the stability selection  - or StARS in the context of network.

- Basically, it uses resampling to estimate robustness of each edges in the network.
- we keep the value of the penalty that guarantees a given level of robustness in the whole network

.important[Careful!]: its is computationally expensive.

--

In `getBestModel`, when "StARS" is requested, stabiltiy selection is performed if needed:


```r
net3 &lt;- getBestModel(networks_mollusc_site, "StARS") 
```

---
# Conclusion

## Summary

  - PLN = generic model for multivariate count data analysis
  - Allows for covariates
  - Flexible modeling of the covariance structure
  - Efficient VEM algorithm

&lt;br /&gt;

## Extensions

- Other covariance structures (spatial, time series, ...)
- Mixture model in the latent space
- Confidence interval and tests for the regular PLN
- Other optimization (composite likelihood, MCMC) starting from the variational solution

---
# References

Aitchison, J. and C. Ho (1989). "The multivariate Poisson-log
normal distribution". In: _Biometrika_ 76.4, pp. 643-653.

Chiquet, J, M. Mariadassou and S. Robin (2018a). "Variational
inference for probabilistic Poisson PCA". In: _The Annals of
Applied Statistics_ 12, pp. 2674-2698. URL:
[http://dx.doi.org/10.1214/18-AOAS1177](http://dx.doi.org/10.1214/18-AOAS1177).

Chiquet, J, M. Mariadassou and S. Robin (2018b). "Variational
inference for sparse network reconstruction from count data". In:
_arXiv preprint_. URL:
[https://arxiv.org/abs/1806.03120](https://arxiv.org/abs/1806.03120).

Inouye, D. I, E. Yang, G. I. Allen, et al. (2017). "A review of
multivariate distributions for count data derived from the Poisson
distribution". In: _Wiley Interdisciplinary Reviews: Computational
Statistics_ 9.3.

Johnson, S. G. (2011). _The NLopt nonlinear-optimization package_.
URL:
[http://ab-initio.mit.edu/nlopt](http://ab-initio.mit.edu/nlopt).

Karlis, D. (2005). "EM algorithm for mixed Poisson and other
discrete distributions". In: _Astin bulletin_ 35.01, pp. 3-24.

Mardia, K, J. Kent and J. Bibby (1979). _Multivariate analysis_.
Academic press.

Richardot-Coulet, M, D. Chessel and M. Bournaud (1986).
"Typological value of the benthos of old beds of a large river.
Methodological approach." In: _Archiv fur Hydrobiologie.
Stuttgart_ 107.3, pp. 363-383.

Svanberg, K. (2002). "A class of globally convergent optimization
methods based on conservative convex separable approximations".
In: _SIAM journal on optimization_ 12.2, pp. 555-573.

Wainwright, M. J. and M. I. Jordan (2008). "Graphical Models,
Exponential Families, and Variational Inference". In: _Found.
Trends Mach. Learn._ 1.1-2, pp. 1-305.
    </textarea>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
